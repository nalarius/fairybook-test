# Fairybook Technical Brief

## Overview
Fairybook is a six-step Streamlit experience for building Korean children's stories with supporting artwork generated by Google Gemini. The refactored architecture splits responsibilities across modules: `app.py` orchestrates the flow, `ui/` hosts the individual page surfaces, `session_state.py` keeps reruns stable, and `services/story_service.py` handles HTML exports. `gemini_client.py` continues to centralize all Gemini prompt building and response handling. A pre-production pass seeds every story with a synopsis, protagonist dossier, locked illustration style, and character concept art before users commit to the title. Static JSON assets provide reusable story archetypes, endings, and illustration styles that keep the interface lightweight and deterministic.

## UI Flow & Session State
- **Step 0 ‚Äì Mode selection**: Users choose between creating a new story, viewing saved exports, or opening the temporary collaboration board. Story creation and the board now require a Firebase login; unauthenticated visitors clicking those options are redirected to the auth gate, while the saved-story viewer remains public. `session_state.ensure_state()` seeds every session key once to avoid Streamlit rerun glitches, and the board UI lives in `ui/board.py` so the story flow stays isolated.
- **Step 1 ‚Äì Audience & idea**: Form widgets write to transient keys (`age_input`, `topic_input`). Confirmed values are copied to `age` and `topic` only upon form submission.
- **Step 2 ‚Äì Story type & title**: Eight random archetypes from `storytype.json` feed the thumbnail picker. Pressing **‚ú® Ï†úÎ™© ÎßåÎì§Í∏∞** triggers an orchestrated pipeline that drafts a synopsis, synthesises a protagonist brief, locks a random illustration style, renders a character concept image, and finally generates the title and cover prompt.
- **Step 3 ‚Äì Cover preview**: The generated artifacts (title, synopsis, protagonist profile, character art, and cover illustration) are shown together so the user can validate tone and style before committing to stage generation. The chosen art style is persisted for the remainder of the session.
- **Step 4 ‚Äì Narrative card selection**: Four cards sampled from `story.json` steer the current stage (the finale automatically draws from `ending.json` so the conclusion can lean Î∞ùÏùå¬∑ÎπÑÍ∑π¬∑Ïó¥Î¶º Îì± ÏõêÌïòÎäî ÌÜ§ÏúºÎ°ú Í∞àÎ¨¥Î¶¨ÎêúÎã§). Users can re-sample cards or backtrack without losing the cover art or selected style.
- **Step 5 ‚Äì Stage results**: Gemini writes the requested stage using summaries of prior stages plus the synopsis/protagonist context to maintain continuity. Illustration prompts reuse the locked style and optionally feed the character concept art as a reference image.
- **Step 6 ‚Äì Saved story recap**: When all stages are complete, the full story appears with cover and stage separators. An export signature prevents duplicate saves while the HTML bundle is auto-generated and surfaced to the user. The same viewer powers **üìÇ Ï†ÄÏû•Î≥∏ Î≥¥Í∏∞**, merging recorded metadata with any legacy exports, and introduces a login-gated **ÎÇ¥ ÎèôÌôî** filter that hides other users‚Äô stories.

Key helpers such as `session_state.go_step()` and the service-layer `export_story_to_html()` keep navigation and exporting predictable amid Streamlit reruns.

## Authentication Flow
- `firebase_auth.py` wraps the Firebase Identity Toolkit REST API for sign-up, sign-in, and refresh while reusing the Admin SDK to verify ID tokens.
- `utils.auth.ensure_active_auth_session()` refreshes expiring tokens on rerun and clears state when refresh fails; `app.py` invokes it at the top of each execution.
- Story creation and the community board call `render_auth_gate()` when visitors are unauthenticated; `auth_next_action` records the requested destination so post-login redirects land where the user intended.
- The header's popover bundles login, logout, and (future) settings actions to keep the main layout uncluttered while surfacing the active display name.

## Story Generation Pipeline
1. `generate_synopsis_with_gemini()` drafts a concise premise tailored to the selected age band, topic, and story-type guidance while keeping both bright and tense beats in play.
2. `generate_protagonist_with_gemini()` expands that premise into a protagonist dossier (motivations, quirks, emotional hooks) that later prompts reuse for tone consistency.
3. `build_character_image_prompt()` composes an illustration directive for the protagonist; the resulting prompt feeds `generate_image_with_gemini()` to produce a reference portrait that can guide subsequent stage art.
4. `generate_title_with_gemini()` consumes the age band, topic, archetype, synopsis, and protagonist notes to deliver a single JSON title payload.
5. Each narrative card triggers `generate_story_with_gemini()`, which now receives the stage metadata, prior stage summaries, synopsis, and protagonist brief so Gemini can weave callbacks across the full arc.
6. The Gemini text model (default `models/gemini-2.5-flash`, override with `GEMINI_TEXT_MODEL`) generates a response. `_extract_text_from_response()` tolerates both direct `.text` outputs and `candidates[0].content.parts` lists.
7. Markdown fences (```json) are stripped before `json.loads()` runs. Missing or malformed data produces a structured error message stored in `st.session_state["story_error"]`.
8. Successful results expose `title` and `paragraphs` fields back to the Streamlit layer for rendering; the UI omits per-stage downloads to keep readers focused on continuity.

## Illustration Pipeline
1. `build_image_prompt()` lazily loads `illust_styles.json`, caches the parsed list, and honours a `style_override` seeded during pre-production so the art direction stays consistent across protagonist art, cover visuals, and every stage.
2. A directive prompt summarises the story (or individual stage), injects the style descriptor, references the protagonist beats, and instructs Gemini to reply with a single English text prompt. Character concept art is still passed as an auxiliary `image_input` when available, while `use_reference_image` remains off so the text prompt stays focused on the stage brief.
3. The cleaned prompt string feeds `generate_image_with_gemini()` which runs against the configured multimodal model (default `gemini-1.5-flash`). At the moment there are no Imagen fallbacks configured; switching models requires updating the environment-driven constants.
4. `_extract_image_from_response()` normalises the various SDK response shapes, returning raw bytes and MIME type. Failures bubble up with descriptive copy surfaced in the UI.

## Data Assets
- **`storytype.json`** ‚Äì Card metadata (`id`, `name`, `prompt`, `illust`) used both for UX text and image thumbnails.
- **`story.json`** ‚Äì Storyline fragments and reusable beats to keep outputs on-theme.
- **`ending.json`** ‚Äì Optional ending templates the model may reference when crafting conclusions.
- **`illust_styles.json`** ‚Äì Named illustration styles; each entry contains `name` and `style` descriptors consumed by the prompt generator.

All JSON files are UTF-8 encoded and loaded lazily so Streamlit reruns stay responsive. When editing, maintain the existing schema to avoid breaking cached reads.

## Configuration & Environment
- `.env` holds `GEMINI_API_KEY` (required) and optional `GEMINI_IMAGE_MODEL`. Loading happens once on module import via `python-dotenv`.
- Firebase auth relies on `FIREBASE_WEB_API_KEY`, `GCP_PROJECT_ID`, and the shared service-account JSON (pointed to by `GOOGLE_APPLICATION_CREDENTIALS` / `FIREBASE_SERVICE_ACCOUNT`). The helper module `firebase_auth.py` handles Identity Toolkit REST calls, token refresh, and Admin SDK verification.
- The `scripts/verify_firebase_admin.py` utility loads `.env`, resolves credentials, and performs a dummy custom-token round trip to validate Admin SDK access before running Streamlit.
- The default text model is `models/gemini-2.5-flash`; adjust `GEMINI_TEXT_MODEL` in your `.env` when latency or cost trade-offs change.
- Illustration model selection is environment-driven via `_IMAGE_MODEL`; use `genai.list_models()` during development to verify availability before changing defaults.

## Error Handling & UX Feedback
- Missing secrets, empty JSON payloads, and Gemini safety blocks propagate as structured `{"error": ...}` dictionaries so the UI can surface localized Korean messages.
- HTML exports convert images to base64 data URIs, making each bundle self-contained. Filenames use a timestamp plus slugified title to prevent collisions.
- If Gemini returns verbose text around the JSON payload, `_extract_first_json_object()` slices out the first object so stage generation can recover without surfacing raw parsing errors.
- When illustration generation fails, the UI surfaces the prompt for debugging and encourages the user to retry before moving on; the locked style ensures later stages stay visually consistent once a cover is accepted.
- Activity logging flows through `telemetry.emit_log_event()`. The `story start` event now captures the selected story type and the normalized topic text in `param4` so analytics dashboards can segment by intent.

## Extending the App
- **New archetypes or styles**: append entries to the respective JSON files and add matching thumbnails under `illust/` (512√ó512 PNG recommended).
- **Prompt tuning**: adjust the synopsis/protagonist builders and character art prompt templates in `gemini_client.py` to rebalance tone or introduce new guidance without touching the Streamlit layer.
- **Alternative models**: update `_MODEL` or `_IMAGE_MODEL` constants once availability is verified via `genai.list_models()`.
- **Testing**: the `tests/test_gemini_client.py` suite exercises prompt builders, JSON parsing helpers, and Gemini orchestration by mocking `google.generativeai.GenerativeModel`. Expand coverage for additional modules while keeping network calls stubbed to preserve quota.
- **Deployment**: ensure `.env` is managed securely (Streamlit Cloud secrets, environment variables, etc.) and write-protect `html_exports/` as needed for multi-user environments.

## Manual Verification Checklist
- Launch the app locally (headless or standard) and walk through Steps 0‚Äì6 using multiple story types and narrative cards.
- During Step 2 validate that the synopsis, protagonist brief, illustration style, character concept art, title, and cover all populate together and respect the tone guidance.
- Confirm illustration thumbnails load from `illust/` and that the cover locks a style reused across all stages.
- Let the recap screen finish its automatic export (toast confirms success) and open the resulting HTML bundle via the viewer.
- Restart the app to ensure session state resets gracefully while cached story assets persist.

For additional context or agent guidelines, see `AGENTS.md`. Board-related changes should remain scoped to `community_board.py` and the dedicated UI helpers in `app.py` so the feature can be disabled without touching the story pipeline.
