# Fairybook Technical Brief

## Overview
Fairybook is a six-step Streamlit experience for building Korean children's stories with supporting artwork generated by Google Gemini. The UI in `app.py` manages session state across reruns, while `gemini_client.py` centralizes all Gemini prompt building and response handling. A pre-production pass now seeds every story with a synopsis, protagonist dossier, locked illustration style, and character concept art before users commit to the title. Static JSON assets provide reusable story archetypes, endings, and illustration styles that keep the interface lightweight and deterministic.

## UI Flow & Session State
- **Step 0 ‚Äì Mode selection**: Users choose between creating a new story or viewing saved exports. The helper `ensure_state()` seeds every session key once to avoid Streamlit rerun glitches.
- **Step 1 ‚Äì Audience & idea**: Form widgets write to transient keys (`age_input`, `topic_input`). Confirmed values are copied to `age` and `topic` only upon form submission.
- **Step 2 ‚Äì Story type & title**: Eight random archetypes from `storytype.json` feed the thumbnail picker. Pressing **‚ú® Ï†úÎ™© ÎßåÎì§Í∏∞** triggers an orchestrated pipeline that drafts a synopsis, synthesises a protagonist brief, locks a random illustration style, renders a character concept image, and finally generates the title and cover prompt.
- **Step 3 ‚Äì Cover preview**: The generated artifacts (title, synopsis, protagonist profile, character art, and cover illustration) are shown together so the user can validate tone and style before committing to stage generation. The chosen art style is persisted for the remainder of the session.
- **Step 4 ‚Äì Narrative card selection**: Four cards sampled from `story.json` steer the current stage (the finale automatically draws from `ending.json` so the conclusion can lean Î∞ùÏùå¬∑ÎπÑÍ∑π¬∑Ïó¥Î¶º Îì± ÏõêÌïòÎäî ÌÜ§ÏúºÎ°ú Í∞àÎ¨¥Î¶¨ÎêúÎã§). Users can re-sample cards or backtrack without losing the cover art or selected style.
- **Step 5 ‚Äì Stage results**: Gemini writes the requested stage using summaries of prior stages plus the synopsis/protagonist context to maintain continuity. Illustration prompts reuse the locked style and optionally feed the character concept art as a reference image.
- **Step 6 ‚Äì Saved story recap**: When all stages are complete, the full story appears with cover and stage separators. An export signature prevents duplicate saves while the HTML bundle is auto-generated and surfaced to the user. The same viewer powers **üìÇ Ï†ÄÏû•Î≥∏ Î≥¥Í∏∞** for past exports.

Key helpers such as `go_step()`, `list_html_exports()`, and `_build_story_html_document()` keep navigation and exporting predictable amid Streamlit reruns.

## Story Generation Pipeline
1. `generate_synopsis_with_gemini()` drafts a concise premise tailored to the selected age band, topic, and story-type guidance while keeping both bright and tense beats in play.
2. `generate_protagonist_with_gemini()` expands that premise into a protagonist dossier (motivations, quirks, emotional hooks) that later prompts reuse for tone consistency.
3. `build_character_image_prompt()` composes an illustration directive for the protagonist; the resulting prompt feeds `generate_image_with_gemini()` to produce a reference portrait that can guide subsequent stage art.
4. `generate_title_with_gemini()` consumes the age band, topic, archetype, synopsis, and protagonist notes to deliver a single JSON title payload.
5. Each narrative card triggers `generate_story_with_gemini()`, which now receives the stage metadata, prior stage summaries, synopsis, and protagonist brief so Gemini can weave callbacks across the full arc.
6. The Gemini text model (`gemini-1.5-flash`) generates a response. `_extract_text_from_response()` tolerates both direct `.text` outputs and `candidates[0].content.parts` lists.
7. Markdown fences (```json) are stripped before `json.loads()` runs. Missing or malformed data produces a structured error message stored in `st.session_state["story_error"]`.
8. Successful results expose `title` and `paragraphs` fields back to the Streamlit layer for rendering; the UI omits per-stage downloads to keep readers focused on continuity.

## Illustration Pipeline
1. `build_image_prompt()` lazily loads `illust_styles.json`, caches the parsed list, and honours a `style_override` seeded during pre-production so the art direction stays consistent across protagonist art, cover visuals, and every stage.
2. A directive prompt summarises the story (or individual stage), injects the style descriptor, references the protagonist beats, and instructs Gemini to reply with a single English text prompt. When character concept art exists it sets `use_reference_image=True` so `generate_image_with_gemini()` can accept the bytes as `image_input`.
3. The cleaned prompt string feeds `generate_image_with_gemini()` which runs against the configured multimodal model (default `gemini-1.5-flash`). Fallbacks remain available for Imagen endpoints when necessary.
4. `_extract_image_from_response()` normalises the various SDK response shapes, returning raw bytes and MIME type. Failures bubble up with descriptive copy surfaced in the UI.

## Data Assets
- **`storytype.json`** ‚Äì Card metadata (`id`, `name`, `prompt`, `illust`) used both for UX text and image thumbnails.
- **`story.json`** ‚Äì Storyline fragments and reusable beats to keep outputs on-theme.
- **`ending.json`** ‚Äì Optional ending templates the model may reference when crafting conclusions.
- **`illust_styles.json`** ‚Äì Named illustration styles; each entry contains `name` and `style` descriptors consumed by the prompt generator.

All JSON files are UTF-8 encoded and loaded lazily so Streamlit reruns stay responsive. When editing, maintain the existing schema to avoid breaking cached reads.

## Configuration & Environment
- `.env` holds `GEMINI_API_KEY` (required) and optional `GEMINI_IMAGE_MODEL`. Loading happens once on module import via `python-dotenv`.
- The default text model is `gemini-1.5-flash`; adjust `_MODEL` in `gemini_client.py` if latency or cost trade-offs change.
- Illustration fallbacks keep legacy Imagen endpoints working for older SDKs. Use `genai.list_models()` during development to verify availability before changing defaults.

## Error Handling & UX Feedback
- Missing secrets, empty JSON payloads, and Gemini safety blocks propagate as structured `{"error": ...}` dictionaries so the UI can surface localized Korean messages.
- HTML exports convert images to base64 data URIs, making each bundle self-contained. Filenames use a timestamp plus slugified title to prevent collisions.
- If Gemini returns verbose text around the JSON payload, `_extract_first_json_object()` slices out the first object so stage generation can recover without surfacing raw parsing errors.
- When illustration generation fails, the UI surfaces the prompt for debugging and encourages the user to retry before moving on; the locked style ensures later stages stay visually consistent once a cover is accepted.

## Extending the App
- **New archetypes or styles**: append entries to the respective JSON files and add matching thumbnails under `illust/` (512√ó512 PNG recommended).
- **Prompt tuning**: adjust the synopsis/protagonist builders and character art prompt templates in `gemini_client.py` to rebalance tone or introduce new guidance without touching the Streamlit layer.
- **Alternative models**: update `_MODEL` or `_IMAGE_MODEL` constants, and keep fallbacks in sync with available endpoints.
- **Testing**: the `tests/test_gemini_client.py` suite exercises prompt builders, JSON parsing helpers, and Gemini orchestration by mocking `google.generativeai.GenerativeModel`. Expand coverage for additional modules while keeping network calls stubbed to preserve quota.
- **Deployment**: ensure `.env` is managed securely (Streamlit Cloud secrets, environment variables, etc.) and write-protect `html_exports/` as needed for multi-user environments.

## Manual Verification Checklist
- Launch the app locally (headless or standard) and walk through Steps 0‚Äì6 using multiple story types and narrative cards.
- During Step 2 validate that the synopsis, protagonist brief, illustration style, character concept art, title, and cover all populate together and respect the tone guidance.
- Confirm illustration thumbnails load from `illust/` and that the cover locks a style reused across all stages.
- Use **HTMLÎ°ú Ï†ÄÏû•** on the recap screen and validate the saved file opens correctly via the viewer.
- Restart the app to ensure session state resets gracefully while cached story assets persist.

For additional context or agent guidelines, see `AGENTS.md`.
